<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>BCS702 - PARALLEL COMPUTING LAB</title>
<script src="https://cdn.tailwindcss.com"></script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet" />
<style>
  body { font-family:'Inter',sans-serif; background:#020617; color:#e2e8f0; overflow:hidden; user-select:none; }
  .main-container { height:100vh; display:flex; flex-direction:column; }
  .nav-scroller { -ms-overflow-style:none; scrollbar-width:none; }
  .nav-scroller::-webkit-scrollbar { display:none; }
  .nav-number { font-size:3rem; font-weight:800; color:#475569; cursor:pointer; position:relative; transition:color .3s; padding:0 1.5rem; }
  .nav-number:hover { color:#94a3b8; }
  .nav-number.active { color:#f8fafc; }
  .nav-number.active::after {
    content:''; position:absolute; left:10%; right:10%; bottom:10%; height:4px;
    background:linear-gradient(90deg,transparent,#f59e0b,#fbbf24,transparent);
    background-size:200% 100%; animation:slide-glow 4s linear infinite alternate; opacity:.7; border-radius:2px;
  }
  @keyframes slide-glow { from{background-position:100% 0} to{background-position:-100% 0} }
  .content-container { flex-grow:1; position:relative; overflow:hidden; }
  .experiment-content { position:absolute; inset:0; padding:2rem; transform:translateX(100%); transition:transform .6s cubic-bezier(.25,1,.5,1); opacity:0; visibility:hidden; overflow-y:auto; }
  .experiment-content.active { transform:translateX(0); opacity:1; visibility:visible; }
  .code-block { background:#1e293b; color:#e2e8f0; border-radius:.5rem; padding:1rem; position:relative; overflow-x:auto; }
  /* Mobile menu */
  .mobile-menu-enter { transform:scaleY(0); transform-origin:top; opacity:0; }
  .mobile-menu-enter.active { transform:scaleY(1); opacity:1; }
</style>
</head>
<body class="antialiased">
  <div class="main-container">
    <header class="py-8 px-6">
      <div class="flex items-center justify-between">
        <a href="https://bcs702.vercel.app/"
           class="bg-slate-700 text-slate-200 px-4 py-2 rounded hover:bg-slate-600 transition">‚Üê Back to Home</a>

        <!-- Hamburger (mobile only) -->
        <button id="menuBtn"
          class="md:hidden inline-flex items-center gap-2 bg-slate-700 hover:bg-slate-600 text-slate-200 px-3 py-2 rounded transition"
          aria-controls="mobileMenu" aria-expanded="false">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path stroke-linecap="round" stroke-linejoin="round" d="M4 6h16M4 12h16M4 18h16"/>
          </svg>
          <span>Experiments</span>
        </button>
      </div>
      <h1 class="text-4xl font-bold text-slate-100 text-center mt-4">BCS702 - PARALLEL COMPUTING LAB</h1>
      <p class="text-lg text-slate-400 text-center mt-2">Select an experiment to view its details</p>
    </header>

    <!-- Desktop number strip -->
    <nav class="w-full py-4 border-y border-slate-800 hidden md:block">
      <div id="nav-container" class="nav-scroller flex justify-center items-center overflow-x-auto"></div>
    </nav>

    <!-- Mobile dropdown menu -->
    <div id="mobileMenu"
         class="md:hidden origin-top mobile-menu-enter bg-[#0b1220] border-y border-slate-800 px-4 hidden">
      <div id="mobileMenuList" class="grid grid-cols-4 gap-3 py-4"></div>
    </div>

    <main class="content-container"></main>
  </div>

  <script>
    document.addEventListener('contextmenu', e => e.preventDefault());

    /* ------------------------ DATA ------------------------ */
    const experiments = [
      { title:"Parallel Merge Sort",
        question:"Write an OpenMP program to sort an array of `n` elements using both sequential and parallel merge sort (using the `sections` directive). Record and print the difference in execution time between the two methods.",
        code:`#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#include <time.h>\n\n#define MIN_SIZE 1000\n\nvoid merge(int arr[], int left, int mid, int right) {\n    int i, j, k;\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n    int *L = (int *)malloc(n1 * sizeof(int));\n    int *R = (int *)malloc(n2 * sizeof(int));\n\n    for (i = 0; i < n1; i++) L[i] = arr[left + i];\n    for (j = 0; j < n2; j++) R[j] = arr[mid + 1 + j];\n\n    i = 0; j = 0; k = left;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) arr[k++] = L[i++];\n        else arr[k++] = R[j++];\n    }\n    while (i < n1) arr[k++] = L[i++];\n    while (j < n2) arr[k++] = R[j++];\n    free(L);\n    free(R);\n}\n\nvoid mergeSortSequential(int arr[], int left, int right) {\n    if (left < right) {\n        int mid = left + (right - left) / 2;\n        mergeSortSequential(arr, left, mid);\n        mergeSortSequential(arr, mid + 1, right);\n        merge(arr, left, mid, right);\n    }\n}\n\nvoid mergeSortParallel(int arr[], int left, int right) {\n    if ((right - left + 1) <= MIN_SIZE) { mergeSortSequential(arr, left, right); return; }\n    if (left < right) {\n        int mid = left + (right - left) / 2;\n        #pragma omp parallel sections\n        { #pragma omp section { mergeSortParallel(arr, left, mid); }\n          #pragma omp section { mergeSortParallel(arr, mid + 1, right); } }\n        merge(arr, left, mid, right);\n    }\n}\n\nint main(){ int n=100000; int *arr_seq=(int*)malloc(n*sizeof(int)), *arr_par=(int*)malloc(n*sizeof(int));\n  srand(time(0)); for(int i=0;i<n;i++){ arr_par[i]=arr_seq[i]=rand()%10000; }\n  printf(\"Sorting %d elements...\\n\\n\", n);\n  double t=omp_get_wtime(); mergeSortSequential(arr_seq,0,n-1); double ts=omp_get_wtime()-t; printf(\"Sequential Merge Sort Time: %f seconds\\n\", ts);\n  t=omp_get_wtime(); mergeSortParallel(arr_par,0,n-1); double tp=omp_get_wtime()-t; printf(\"Parallel Merge Sort Time:   %f seconds\\n\", tp);\n  printf(\"\\nDifference (Sequential - Parallel): %f seconds\\n\", ts-tp); if(tp>0) printf(\"Speedup: %.2fx\\n\", ts/tp);\n  printf(\"\\nVerification: First 20 elements of the sorted array:\\n\"); for(int i=0;i<(n<20?n:20);i++) printf(\"%d \", arr_par[i]); printf(\"\\n\"); free(arr_seq); free(arr_par); return 0; }`,
        explanation:"The `parallel sections` run left/right halves concurrently; `MIN_SIZE` avoids tiny-task overhead.",
        output:`Sorting 100000 elements...\n\nSequential Merge Sort Time: 0.048000 seconds\nParallel Merge Sort Time:   0.025000 seconds\n\nDifference (Sequential - Parallel): 0.023000 seconds\nSpeedup: 1.92x\n\nVerification: First 20 elements of the sorted array:\n0 1 1 2 3 4 5 5 6 7 8 8 9 9 10 11 12 13 14 15`
      },
      /* --- keep the rest of your experiments unchanged --- */
      { title:"Static Loop Scheduling", question:"Write an OpenMP program that divides the iterations into chunks containing 2 iterations, respectively (OMP_SCHEDULE=static,2). Its input should be the number of iterations, and its output should be which iterations of a parallelized for loop are executed by which thread.", code:`#include <stdio.h>\n#include <omp.h>\n\nint main(){ int num_iterations; printf("Enter the number of iterations: "); scanf("%d",&num_iterations);\n  #pragma omp parallel { #pragma omp for schedule(static,2)\n    for(int i=0;i<num_iterations;i++){ printf("Thread %d: Iteration %d\\n", omp_get_thread_num(), i); } }\n  return 0; }`, explanation:"Static,2 chunks work is pre-split in round-robin; low overhead, predictable.", output:`Enter the number of iterations: 8\nThread 0: Iteration 0\nThread 0: Iteration 1\nThread 2: Iteration 4\nThread 2: Iteration 5\nThread 1: Iteration 2\nThread 1: Iteration 3\nThread 3: Iteration 6\nThread 3: Iteration 7\n\nNote: The output order might be jumbled due to the parallel nature of printf.` },
      { title:"Task-based Fibonacci", question:"Write an OpenMP program to calculate n Fibonacci numbers using tasks.", code:`#include <stdio.h>\n#include <omp.h>\n\nint fib(int n){ int i,j; if(n<2) return n; else{ #pragma omp task shared(i) firstprivate(n) i=fib(n-1); #pragma omp task shared(j) firstprivate(n) j=fib(n-2); #pragma omp taskwait return i+j; } }\nint main(){ int n; printf("Enter the Fibonacci number to calculate: "); scanf("%d",&n); omp_set_dynamic(0); omp_set_num_threads(4);\n  #pragma omp parallel shared(n){ #pragma omp single printf("fib(%d) = %d\\n", n, fib(n)); } return 0; }`, explanation:"Tasks split the recursive calls; `taskwait` syncs before summation; great demo, not optimal for big n.", output:`Enter the Fibonacci number to calculate: 12\nfib(12) = 144` },
      { title:"Parallel Prime Finder", question:"Write an OpenMP program to find the prime numbers from 1 to n employing parallel for directive. Record both serial and parallel execution times.", code:`#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#include <math.h>\nint is_prime(int x){ if(x<=1) return 0; if(x==2) return 1; if(x%2==0) return 0; for(int i=3;i<=sqrt(x);i+=2){ if(x%i==0) return 0; } return 1; }\nint main(){ int n; printf("Enter the upper limit (n) to find prime numbers: "); scanf("%d",&n); if(n<2){ printf("There are no prime numbers up to %d.\\n", n); return 0; }\n  printf("\\nFinding prime numbers from 1 to %d...\\n", n); double t=omp_get_wtime(); int sp=0; for(int i=1;i<=n;i++){ if(is_prime(i)) sp++; } double ts=omp_get_wtime()-t;\n  printf("\\nSequential: Found %d primes in %f seconds\\n", sp, ts); t=omp_get_wtime(); int pp=0; #pragma omp parallel for reduction(+:pp) schedule(dynamic) for(int i=1;i<=n;i++){ if(is_prime(i)) pp++; } double tp=omp_get_wtime()-t; printf("Parallel:   Found %d primes in %f seconds\\n", pp, tp); if(tp>0 && ts>0) printf("\\nSpeedup: %.2fx\\n", ts/tp); return 0; }`, explanation:"`parallel for` + `reduction` avoids races; `dynamic` smooths workload.", output:`Enter the upper limit (n) to find prime numbers: 200000\n\nFinding prime numbers from 1 to 200000...\n\nSequential: Found 17984 primes in 0.035000 seconds\nParallel:   Found 17984 primes in 0.009000 seconds\n\nSpeedup: 3.89x` },
      { title:"MPI Send/Recv", question:"Write a MPI Program to demonstration of MPI_Send and MPI_Recv.", code:`#include <stdio.h>\n#include <mpi.h>\nint main(int argc,char*argv[]){ int rank,size,number; MPI_Init(&argc,&argv); MPI_Comm_size(MPI_COMM_WORLD,&size); MPI_Comm_rank(MPI_COMM_WORLD,&rank); if(size<2){ if(rank==0) printf("This program requires at least 2 processes.\\n"); MPI_Finalize(); return 0; }\n  if(rank==0){ number=42; printf("Process 0 is sending number %d to Process 1\\n", number); MPI_Send(&number,1,MPI_INT,1,0,MPI_COMM_WORLD); }\n  else if(rank==1){ MPI_Recv(&number,1,MPI_INT,0,0,MPI_COMM_WORLD,MPI_STATUS_IGNORE); printf("Process 1 received number %d from Process 0\\n", number); }\n  MPI_Finalize(); return 0; }`, explanation:"Basic point-to-point send/recv demo.", output:"Process 0 is sending number 42 to Process 1\nProcess 1 received number 42 from Process 0" },
      { title:"MPI Deadlock", question:"Write a MPI program to demonstration of deadlock using point to point communication and avoidance of deadlock by altering the call sequence.", code:`#include <stdio.h>\n#include <mpi.h>\nint main(int argc,char*argv[]){ int rank,s,r; MPI_Init(&argc,&argv); MPI_Comm_rank(MPI_COMM_WORLD,&rank); s=rank; if(rank==0){ MPI_Send(&s,1,MPI_INT,1,0,MPI_COMM_WORLD); MPI_Recv(&r,1,MPI_INT,1,0,MPI_COMM_WORLD,MPI_STATUS_IGNORE); }\n  else if(rank==1){ MPI_Send(&s,1,MPI_INT,0,0,MPI_COMM_WORLD); MPI_Recv(&r,1,MPI_INT,0,0,MPI_COMM_WORLD,MPI_STATUS_IGNORE); }\n  printf("Process %d received %d\\n", rank, r); MPI_Finalize(); return 0; }`, explanation:"Two-way send/recv; ordering matters for deadlock avoidance.", output:"Process 1 received message: 0\nProcess 0 received message: 1" },
      { title:"MPI Broadcast", question:"Write a MPI Program to demonstration of Broadcast operation.", code:`#include <stdio.h>\n#include <mpi.h>\nint main(int argc,char**argv){ int rank,data=0; MPI_Init(&argc,&argv); MPI_Comm_rank(MPI_COMM_WORLD,&rank); if(rank==0) data=100; MPI_Bcast(&data,1,MPI_INT,0,MPI_COMM_WORLD); printf("Process %d received data: %d\\n", rank, data); MPI_Finalize(); return 0; }`, explanation:"Root shares a value with everyone using `MPI_Bcast`.", output:"Process 0 received data: 100\nProcess 1 received data: 100\nProcess 2 received data: 100\nProcess 3 received data: 100" },
      { title:"MPI Scatter/Gather", question:"Write a MPI Program demonstration of MPI_Scatter and MPI_Gather.", code:`#include <stdio.h>\n#include <mpi.h>\nint main(int argc,char**argv){ int rank,size,data[4]={10,20,30,40},recv; MPI_Init(&argc,&argv); MPI_Comm_rank(MPI_COMM_WORLD,&rank); MPI_Comm_size(MPI_COMM_WORLD,&size); MPI_Scatter(data,1,MPI_INT,&recv,1,MPI_INT,0,MPI_COMM_WORLD); recv+=1; MPI_Gather(&recv,1,MPI_INT,data,1,MPI_INT,0,MPI_COMM_WORLD); if(rank==0){ printf("Gathered data: "); for(int i=0;i<size;i++) printf("%d ", data[i]); printf("\\n"); } MPI_Finalize(); return 0; }`, explanation:"Split array out, tweak, pull back in.", output:"Process 0 received: 10\nProcess 1 received: 20\nProcess 2 received: 30\nProcess 3 received: 40\nGathered data: 11 21 31 41" },
      { title:"MPI Reduce", question:"Write a MPI Program to demonstration of MPI_Reduce and MPI_Allreduce (MPI_MAX, MPI_MIN, MPI_SUM, MPI_PROD).", code:`#include <stdio.h>\n#include <mpi.h>\nint main(int argc,char**argv){ int rank,value,sum,prod,max,min; MPI_Init(&argc,&argv); MPI_Comm_rank(MPI_COMM_WORLD,&rank); value=rank+1; MPI_Reduce(&value,&sum,1,MPI_INT,MPI_SUM,0,MPI_COMM_WORLD); MPI_Allreduce(&value,&prod,1,MPI_INT,MPI_PROD,MPI_COMM_WORLD); MPI_Allreduce(&value,&max,1,MPI_INT,MPI_MAX,MPI_COMM_WORLD); MPI_Allreduce(&value,&min,1,MPI_INT,MPI_MIN,MPI_COMM_WORLD); if(rank==0) printf("Reduce SUM (only root): %d\\n", sum); printf("Allreduce PROD (rank %d): %d\\n", rank, prod); printf("Allreduce MAX  (rank %d): %d\\n", rank, max); printf("Allreduce MIN  (rank %d): %d\\n", rank, min); MPI_Finalize(); return 0; }`, explanation:"Sum at root; everyone gets prod/max/min via allreduce.", output:"Sum using Reduce: 10\nMax using Allreduce (rank 0): 4\nMax using Allreduce (rank 1): 4\nMax using Allreduce (rank 2): 4\nMax using Allreduce (rank 3): 4" }
    ];

    /* ------------------------ BUILD UI ------------------------ */
    const navContainer = document.getElementById('nav-container');
    const contentContainer = document.querySelector('.content-container');
    const mobileMenu = document.getElementById('mobileMenu');
    const mobileMenuList = document.getElementById('mobileMenuList');
    const menuBtn = document.getElementById('menuBtn');

    // desktop strip
    experiments.forEach((exp, index) => {
      const navEl = document.createElement('div');
      navEl.className = 'nav-number';
      navEl.textContent = index + 1;
      navEl.onclick = () => showExperiment(index);
      navContainer.appendChild(navEl);
    });

    // mobile grid menu
    experiments.forEach((exp, index) => {
      const a = document.createElement('button');
      a.className =
        'w-full aspect-square rounded-xl bg-slate-700 hover:bg-slate-600 active:scale-95 transition text-2xl font-bold';
      a.textContent = index + 1;
      a.setAttribute('aria-label', `Open experiment ${index + 1}: ${exp.title}`);
      a.onclick = () => {
        showExperiment(index);
        toggleMobileMenu(false);
      };
      mobileMenuList.appendChild(a);
    });

    // content panes
    experiments.forEach((exp) => {
      const contentEl = document.createElement('div');
      contentEl.className = 'experiment-content';
      contentEl.innerHTML = `
        <div class="max-w-4xl mx-auto">
          <h2 class="text-3xl font-bold text-slate-100 mb-6">${exp.title}</h2>
          <div class="space-y-8">
            <div class="bg-slate-800/50 p-6 rounded-lg">
              <h3 class="text-xl font-semibold text-amber-400">Question</h3>
              <p class="text-slate-300 mt-2 whitespace-pre-wrap">${exp.question}</p>
            </div>
            <div class="bg-slate-800/50 p-6 rounded-lg">
              <h3 class="text-xl font-semibold text-amber-400">Code</h3>
              <div class="code-block mt-2"><pre><code>${escapeHtml(exp.code)}</code></pre></div>
            </div>
            <div class="bg-slate-800/50 p-6 rounded-lg">
              <h3 class="text-xl font-semibold text-amber-400">Explanation</h3>
              <p class="text-slate-300 mt-2">${exp.explanation}</p>
            </div>
            <div class="bg-slate-800/50 p-6 rounded-lg">
              <h3 class="text-xl font-semibold text-amber-400">Expected Output</h3>
              <div class="code-block mt-2 !bg-black/50"><pre><code>${exp.output}</code></pre></div>
            </div>
          </div>
        </div>`;
      contentContainer.appendChild(contentEl);
    });

    /* ------------------------ BEHAVIOR ------------------------ */
    function showExperiment(index) {
      navContainer.querySelectorAll('.nav-number').forEach((el, i) => {
        el.classList.toggle('active', i === index);
      });
      contentContainer.querySelectorAll('.experiment-content').forEach((el, i) => {
        el.classList.toggle('active', i === index);
      });
      // also reflect active on mobile buttons (subtle)
      mobileMenuList.querySelectorAll('button').forEach((btn, i) => {
        btn.classList.toggle('ring-2', i === index);
        btn.classList.toggle('ring-amber-400', i === index);
      });
    }

    function escapeHtml(unsafe) {
      return unsafe
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    // mobile menu toggle
    function toggleMobileMenu(forceState) {
      const willOpen = typeof forceState === 'boolean'
        ? forceState
        : mobileMenu.classList.contains('hidden');
      mobileMenu.classList.toggle('hidden', !willOpen);
      requestAnimationFrame(() => {
        mobileMenu.classList.toggle('active', willOpen);
      });
      menuBtn.setAttribute('aria-expanded', String(willOpen));
    }

    menuBtn.addEventListener('click', () => toggleMobileMenu());
    // close on outside tap
    document.addEventListener('click', (e) => {
      if (!mobileMenu.classList.contains('hidden')) {
        const clickInside = mobileMenu.contains(e.target) || menuBtn.contains(e.target);
        if (!clickInside) toggleMobileMenu(false);
      }
    });

    // init
    showExperiment(0);
  </script>
</body>
</html>
